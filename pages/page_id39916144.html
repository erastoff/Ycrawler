<!DOCTYPE html>
<html lang="en">
  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" href="/assets/favicon.webp">
    <link rel="stylesheet" type="text/css" href="https://blog.sequin.io/assets/built/prism.css?v=8b5ec10fbe">
    <link rel="stylesheet" type="text/css" href="https://blog.sequin.io/assets/built/screen.css?v=8b5ec10fbe">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@375;600;700;800&display=swap" rel="stylesheet">

    <title>LiveView is best with Svelte</title>

    <meta name="description" content="Phoenix&#x27;s LiveView is powerful. But it felt like it was missing something. Adding Svelte not only filled a big gap â it introduced us to an entirely new way to develop web apps.">
    <link rel="icon" href="https://blog.sequin.io/content/images/size/w256h256/2024/03/Transparent-S.png" type="image/png">
    <link rel="canonical" href="https://blog.sequin.io/liveview-is-best-with-svelte/">
    <meta name="referrer" content="no-referrer-when-downgrade">
    
    <meta property="og:site_name" content="The Sequin Blog">
    <meta property="og:type" content="article">
    <meta property="og:title" content="LiveView is best with Svelte">
    <meta property="og:description" content="Phoenix&#x27;s LiveView is powerful. But it felt like it was missing something. Adding Svelte not only filled a big gap â it introduced us to an entirely new way to develop web apps.">
    <meta property="og:url" content="https://blog.sequin.io/liveview-is-best-with-svelte/">
    <meta property="og:image" content="https://blog.sequin.io/content/images/size/w1200/2024/04/svelte-logo.png">
    <meta property="article:published_time" content="2024-04-01T17:44:58.000Z">
    <meta property="article:modified_time" content="2024-04-02T23:31:36.000Z">
    <meta property="article:publisher" content="https://www.facebook.com/ghost">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="LiveView is best with Svelte">
    <meta name="twitter:description" content="Phoenix&#x27;s LiveView is powerful. But it felt like it was missing something. Adding Svelte not only filled a big gap â it introduced us to an entirely new way to develop web apps.">
    <meta name="twitter:url" content="https://blog.sequin.io/liveview-is-best-with-svelte/">
    <meta name="twitter:image" content="https://blog.sequin.io/content/images/size/w1200/2024/04/svelte-logo.png">
    <meta name="twitter:label1" content="Written by">
    <meta name="twitter:data1" content="Anthony Accomazzo">
    <meta name="twitter:site" content="@sequin_io">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="480">
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "The Sequin Blog",
        "url": "https://blog.sequin.io/",
        "logo": {
            "@type": "ImageObject",
            "url": "https://blog.sequin.io/content/images/2024/03/NEW-Sequin-Logo---BLACK.svg"
        }
    },
    "author": {
        "@type": "Person",
        "name": "Anthony Accomazzo",
        "image": {
            "@type": "ImageObject",
            "url": "https://blog.sequin.io/content/images/2022/03/fk5lv2WW_400x400.jpg",
            "width": 150,
            "height": 150
        },
        "url": "https://blog.sequin.io/author/anthony/",
        "sameAs": []
    },
    "headline": "LiveView is best with Svelte",
    "url": "https://blog.sequin.io/liveview-is-best-with-svelte/",
    "datePublished": "2024-04-01T17:44:58.000Z",
    "dateModified": "2024-04-02T23:31:36.000Z",
    "image": {
        "@type": "ImageObject",
        "url": "https://blog.sequin.io/content/images/size/w1200/2024/04/svelte-logo.png",
        "width": 1200,
        "height": 480
    },
    "description": "Phoenix&#x27;s LiveView is powerful. But it felt like it was missing something. Adding Svelte not only filled a big gap â it introduced us to an entirely new way to develop web apps.",
    "mainEntityOfPage": "https://blog.sequin.io/liveview-is-best-with-svelte/"
}
    </script>

    <meta name="generator" content="Ghost 5.81">
    <link rel="alternate" type="application/rss+xml" title="The Sequin Blog" href="https://blog.sequin.io/rss/">
    <script defer src="https://cdn.jsdelivr.net/ghost/portal@~2.37/umd/portal.min.js" data-i18n="false" data-ghost="https://blog.sequin.io/" data-key="174577c6460fce1a451631fde3" data-api="https://sequin.ghost.io/ghost/api/content/" crossorigin="anonymous"></script><style id="gh-members-styles">.gh-post-upgrade-cta-content,
.gh-post-upgrade-cta {
    display: flex;
    flex-direction: column;
    align-items: center;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    text-align: center;
    width: 100%;
    color: #ffffff;
    font-size: 16px;
}

.gh-post-upgrade-cta-content {
    border-radius: 8px;
    padding: 40px 4vw;
}

.gh-post-upgrade-cta h2 {
    color: #ffffff;
    font-size: 28px;
    letter-spacing: -0.2px;
    margin: 0;
    padding: 0;
}

.gh-post-upgrade-cta p {
    margin: 20px 0 0;
    padding: 0;
}

.gh-post-upgrade-cta small {
    font-size: 16px;
    letter-spacing: -0.2px;
}

.gh-post-upgrade-cta a {
    color: #ffffff;
    cursor: pointer;
    font-weight: 500;
    box-shadow: none;
    text-decoration: underline;
}

.gh-post-upgrade-cta a:hover {
    color: #ffffff;
    opacity: 0.8;
    box-shadow: none;
    text-decoration: underline;
}

.gh-post-upgrade-cta a.gh-btn {
    display: block;
    background: #ffffff;
    text-decoration: none;
    margin: 28px 0 0;
    padding: 8px 18px;
    border-radius: 4px;
    font-size: 16px;
    font-weight: 600;
}

.gh-post-upgrade-cta a.gh-btn:hover {
    opacity: 0.92;
}</style>
    <script defer src="https://cdn.jsdelivr.net/ghost/sodo-search@~1.1/umd/sodo-search.min.js" data-key="174577c6460fce1a451631fde3" data-styles="https://cdn.jsdelivr.net/ghost/sodo-search@~1.1/umd/main.css" data-sodo-search="https://sequin.ghost.io/" crossorigin="anonymous"></script>
    
    <link href="https://blog.sequin.io/webmentions/receive/" rel="webmention">
    <script defer src="/public/cards.min.js?v=8b5ec10fbe"></script>
    <link rel="stylesheet" type="text/css" href="/public/cards.min.css?v=8b5ec10fbe">
    <script defer src="/public/member-attribution.min.js?v=8b5ec10fbe"></script>
    <script>
  !function(){var analytics=window.analytics=window.analytics||[];if(!analytics.initialize)if(analytics.invoked)window.console&&console.error&&console.error("Segment snippet included twice.");else{analytics.invoked=!0;analytics.methods=["trackSubmit","trackClick","trackLink","trackForm","pageview","identify","reset","group","track","ready","alias","debug","page","once","off","on","addSourceMiddleware","addIntegrationMiddleware","setAnonymousId","addDestinationMiddleware"];analytics.factory=function(e){return function(){var t=Array.prototype.slice.call(arguments);t.unshift(e);analytics.push(t);return analytics}};for(var e=0;e<analytics.methods.length;e++){var key=analytics.methods[e];analytics[key]=analytics.factory(key)}analytics.load=function(key,e){var t=document.createElement("script");t.type="text/javascript";t.async=!0;t.src="https://cdn.segment.com/analytics.js/v1/" + key + "/analytics.min.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(t,n);analytics._loadOptions=e};analytics._writeKey="c3MMLBHZljvh3OSkOEeI0v2wRRNDoDbY";;analytics.SNIPPET_VERSION="4.15.3";
  analytics.load("c3MMLBHZljvh3OSkOEeI0v2wRRNDoDbY");
  analytics.page();
  }}();
    
  !function(t,e){var o,n,p,r;e.__SV||(window.posthog=e,e._i=[],e.init=function(i,s,a){function g(t,e){var o=e.split(".");2==o.length&&(t=t[o[0]],e=o[1]),t[e]=function(){t.push([e].concat(Array.prototype.slice.call(arguments,0)))}}(p=t.createElement("script")).type="text/javascript",p.async=!0,p.src=s.api_host+"/static/array.js",(r=t.getElementsByTagName("script")[0]).parentNode.insertBefore(p,r);var u=e;for(void 0!==a?u=e[a]=[]:a="posthog",u.people=u.people||[],u.toString=function(t){var e="posthog";return"posthog"!==a&&(e+="."+a),t||(e+=" (stub)"),e},u.people.toString=function(){return u.toString(1)+".people (stub)"},o="capture identify alias people.set people.set_once set_config register register_once unregister opt_out_capturing has_opted_out_capturing opt_in_capturing reset isFeatureEnabled onFeatureFlags".split(" "),n=0;n<o.length;n++)g(u,o[n]);e._i.push([i,s,a])},e.__SV=1)}(document,window.posthog||[]);
  
  analytics.ready(function() {
    window.posthog.init("phc_5KzGq2JZfLZuRRBZfTHaSG9kBZLsnmb9fJDpup45pNw", {
      api_host: 'https://app.posthog.com', // Use eu.posthog.com for EU instances
      segment: window.analytics, // Pass window.analytics here - NOTE: window. is important
      capture_pageview: false, // You want this false if you are going to use segment's analytics.page() for pageviews
      autocapture: false, // You want this false if you are going to use segment's analytics.track() for events
    });
  })
</script><style>:root {--ghost-accent-color: #9333ea;}</style>

  </head>
  <body class="post-template">
    <div class="gh-viewport">
      <header class="backdrop-filter backdrop-blur-sm h-20 sticky top-0 z-50 bg-white dark:bg-black bg-opacity-60 dark:bg-opacity-60 transition-colors border-black dark:border-white border-opacity-10 dark:border-opacity-10" id="header-outer">
        <div class="container mx-auto px-4 h-full flex flex-row items-center">
          <a href="https://sequin.io/">
            <img
            class="h-8 dark:hidden"
            src="/assets/sequin-logo-brand-black.svg"
            alt="Sequin"
            />
          </a>
          <div class="flex-1">
          </div>
          <div class="grid grid-flow-col gap-4">
            <a href="https://docs.sequin.io/" class="bg-transparent hover:shadow-xl transition-all text-black font-medium dark:text-white dark:hover:bg-gray-900 text-root px-8 h-12 rounded lg:flex flex-row items-center cursor-pointer hidden font-display">Docs</a>
            <a href="https://sequin.io/pricing" class="bg-transparent hover:shadow-xl transition-all text-black font-medium dark:text-white dark:hover:bg-gray-900 text-root px-8 h-12 rounded lg:flex flex-row items-center cursor-pointer hidden font-display">Pricing</a>
            <a href="https://sequin.io/integrations" class="bg-transparent hover:shadow-xl transition-all text-black font-medium dark:text-white dark:hover:bg-gray-900 text-root px-8 h-12 rounded lg:flex flex-row items-center cursor-pointer hidden font-display">Integrations</a>
            <a href="https://blog.sequin.io/" class="bg-transparent hover:shadow-xl transition-all text-black font-medium dark:text-white dark:hover:bg-gray-900 text-root px-8 h-12 rounded lg:flex flex-row items-center cursor-pointer hidden font-display">Blog</a>
            <a href="https://app.sequin.io/signup" class="bg-transparent hover:shadow-xl transition-all text-black font-medium dark:text-white dark:hover:bg-gray-900 text-root px-8 h-12 rounded lg:flex flex-row items-center cursor-pointer hidden font-display">
              Login
            </a>
            <a class="btn-primary" href="https://app.sequin.io/signup">
              Start free
            </a>
            <div>
              <button class="w-8 h-full lg:hidden" id="hamburger-btn" type="button">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" class="text-black dark:text-white">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16">
                  </path>
                </svg>
              </button>
              <div class="fixed w-full left-0 top-20 right-0 z-50 bg-white dark:bg-gray-800 p-4 grid grid-flow-row gap-y-2 shadow-xl hidden" id="mobile-menu-popover">
                <a class="btn-outlined" href="https://docs.sequin.io">Docs</a>
                <a class="btn-outlined" href="https://sequin.io/pricing">Pricing</a>
                <a class="btn-outlined" href="https://sequin.io/integrations">Integrations</a>
                <a class="btn-outlined" href="https://blog.sequin.io">Blog</a>
                <a class="btn-outlined" href="https://app.sequin.io/signup">Sign up</a>
                <a class="btn-primary" href="https://app.sequin.io/login">Login</a>
              </div>
            </div>
          </div>
        </div>
      </header>

      <main class="gh-main">

        


<div class="px-4 mt-6 sm:mt-10 md:mt-20 mb-20">
  <a class="flex flex-row mx-auto sm:w-10/12 md:w-9/12 lg:w-8/12 xl:w-7/12 2xl:w-6/12" href="/">
    <img src="/assets/arrow-left-24px.svg" alt="left arrow" height="24" width="24">
    <span class="ml-2 sm:ml-3 font-bold text-base">Back to posts</span>
  </a>

  <div class="mx-auto sm:w-10/12 md:w-9/12 lg:w-8/12 xl:w-7/12 2xl:w-6/12">
    <h1 class="my-8 font-bold font-display text-4xl sm:text-5xl md:text-6xl">LiveView is best with Svelte</h1>
    <div class="flex flex-row gap-2 items-center">
        <img class="hidden sm:inline md:hidden rounded-full" src="/content/images/size/w100/2022/03/fk5lv2WW_400x400.jpg" alt="Anthony Accomazzo" height="40" width="40">        
        <img class="hidden md:inline rounded-full" src="/content/images/size/w100/2022/03/fk5lv2WW_400x400.jpg" alt="Anthony Accomazzo" height="50" width="50">
        <!-- To make this ^ work, insert a picture of the author on Ghost Admin-->
        <div class="ml-1 font-bold text-sm sm:text-lg">
          Anthony Accomazzo
        </div>
      <div class="font-bold text-xs">â¢</div>
      <time class="text-sm sm:text-lg">
        Apr 1, 2024
      </time>
      <div class="font-bold text-xs">â¢</div>
      <div class="text-sm sm:text-lg">
        12 min read
      </div>
    </div>
  </div>

  <img
    class="rounded-md mx-auto sm:w-11/12 md:w-10/12 lg:w-9/12 xl:w-8/12 2xl:w-7/12 my-8"
    src="/content/images/2024/04/svelte-logo.png"
    alt="main image of the article"
  >
  <!-- To make this work, insert a featured image on Ghost Admin-->
  
  <div class="relative mx-auto sm:w-10/12 md:w-9/12 lg:w-8/12 xl:w-7/12 2xl:w-6/12">
    <div class="mt-16 post-content-design">
      <p class="post-lead">Weâre <a href="https://sequin.io/?ref=blog.sequin.io">Sequin</a>. We stream data from services like Salesforce, Stripe, and AWS to messaging systems like Kafka and databases like Postgres. As an infrastructure company, we questioned if we really need a SPA. So, we started with LiveView, which helped us move fast but left us wanting more. This post is about that journey.
</p>
<p>Phoenix's <a href="https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html?ref=blog.sequin.io">LiveView</a> has polarized our team. Compared to SPA, there are components and features that weâre able to build 2-3x faster. Conversely, there are components and features that are frustrating to build or feel very counterintuitive.</p>
<p>Said another way, LiveView makes a lot of things easy. But it also makes some easy things hard.</p>
<p>This created tension. Do we keep forging down this path? Or do we give in and convert our app to a SPA?</p>
<p>Fortunately, we found a companion library called <a href="https://github.com/woutdp/live_svelte?ref=blog.sequin.io">LiveSvelte</a>. LiveView enables a development experience with Svelte thatâs unlike any other fullstack paradigm Iâve used.</p>
<p>The team agrees: this is a killer way to build.</p>
<p>To appreciate the LiveView+Svelte paradigm, Iâll start by explaining how LiveView works and what makes it different. Then, Iâll detail the friction we encountered with a pure LiveView approach. At that point, youâll be able to appreciate what LiveSvelte offers.</p>
<h2 id="what-is-liveview">What is LiveView</h2>
<p>LiveView offers a very unique way to build web applications.</p>
<p>In a traditional server-rendered web application, the server is stateless. The client requests a page and the server renders it. All client actions route back to the server, which re-renders the next page.</p>
<p>In a SPA, the client is in charge of building pages. It leverages a backend API to read and write data. Client apps are stateful (e.g. <code>useState</code> in React).</p>
<p>In LiveView, the server is in charge of rendering the page. But itâs stateful. Actions in the frontend are handled by the backend, but the server <em>incrementally</em> updates the DOM, much like in a SPA.</p>
<p>At a high-level, the reason a SPA is complex is because distributed systems are complex. Supporting a client JS app is supporting a microservice (and one that runs in a hostile, untrusted environment, no less!)</p>
<p>In <em>theory</em> your frontend app uses a backend REST API that <em>could</em> be used to support lots of different services and clients. In reality, the needs of your frontend app are unique. So your backend routes and controllers explode with functions that serve the needs of a single client.</p>
<p>If nothing else, this complexity just means shaving a lot of yaks. Each request requires a fair bit of plumbing on both the frontend and the backend. Callstacks can easily exceed half a dozen layers:</p>
<ul>
<li><code>onMount</code></li>
<li><code>await api.fetchUsers</code></li>
<li><code>parseResponse</code></li>
<li><code>Router.handle(/api/users)</code></li>
<li><code>AuthPlug.verify_cookie</code></li>
<li><code>UsersController.index</code></li>
<li><code>Users.list_for_org</code></li>
<li><code>ApiHelpers.prepare_response</code></li>
</ul>
<p>The promise of LiveView is that you get to create rich client-side experiences without the frontend microservice. You're back to the much simpler world where you can query the database in the function adjacent to the function that renders your table rows. If a new row comes in, you just need to push it to your table, and LiveView will update the client for you.</p>
<p>But in addition, you also get to enjoy building an app using the stateful paradigm of frontend frameworks. It's much easier and faster to build rich interaction patterns this way vs prior backend paradigms where you'd need to "rebuild the world" on each request.</p>
<h2 id="where-liveview-makes-easy-things-hard">Where LiveView makes easy things hard</h2>
<p>There's a lot of good stuff in LiveView. But there are also real thorns.</p>
<p>There are two primary areas that we struggled with LiveView:</p>
<h3 id="client-side-state-is-inevitable">Client-side state is inevitable</h3>
<p>There is a (literal) speed of light limitation with this approach: your server can only be <em>so close</em> to your users.</p>
<p>Invariably, youâre going to need to do some stuff client-side. Animations, tooltips, showing/hiding DOM elements, disabling form fields, etc.</p>
<p>For example, thereâs a form in our app with two interdependent dropdowns. Selecting an option in the first dropdown allows our server to generate the list for the second dropdown. To get the best UX, you want to disable the second dropdown immediately after the first dropdown changes. Then, when itâs repopulated by the server, you can re-enable it:</p>
<div style="display: flex; justify-content: center;">
<img src="https://blog.sequin.io/content/images/2024/03/CleanShot-2024-03-28-at-10.58.11-1.gif" alt="Two dropdowns, the second is disabled after the first changes" style="max-height: 250px">
</div>
<p><em>Simulating 1000ms of roundtrip latency between the client and the server.</em></p>
<p>To pull this off, as far as we could tell, you need to use two independent concepts in LiveView:</p>
<ul>
<li>Use the <a href="https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.JS.html?ref=blog.sequin.io">JS module</a> to disable the second dropdown when the first dropdown changes.</li>
<li>Use a <a href="https://hexdocs.pm/phoenix_live_view/js-interop.html?ref=blog.sequin.io#client-hooks-via-phx-hook">hook</a> to register an event listener on the second dropdown. Then, send an action to re-enable the second dropdown from the backend.</li>
</ul>
<p>And for slightly more complex interaction patterns, youâll need to incorporate a <em>third</em> concept, LiveView state. For example, maybe you only want to re-enable the second dropdown in certain conditions.</p>
<p>The way these three concepts fit together is not obvious (weâre still not sure this is the right pattern!)</p>
<p>So, while the server is in charge of a lot of DOM changes, it canât command all of them. You use JS and hooks to sprinkle in JavaScript where needed. These tools feel side-chained to core LiveView, and therefore their patterns of use are not obvious. And the more JS and hooks you use, the more of your DOM state now exists <em>outside</em> of LiveView.</p>
<p>This is a stark contrast to a paradigm like React. In React, itâs state and actions all the way down. With that core concept, you can do most anything. And there is no blurry line between DOM state and component state.</p>
<p>React can take that approach because thereâs no latency between client-side actions and client-side state. This means you can let Reactâs state paradigm handle every action and transition. Because all of LiveViewâs state is server-side, it has to contend with the latency between client-side actions and server-side state. This means that while LiveView state <em>looks like</em> other frontend frameworks, the model is actually quite different.</p>
<p>Take input fields, for example. In React, a character canât be inserted into an input field without routing through state. This unlocks a powerful programming model, where your component re-renders â and therefore responds â to every keystroke. It gives the state and action paradigm a lot of reach, where you can use one core concept (<code>useState</code>) to solve a huge space of problems.</p>
<p>In LiveView, itâs more accurate to say that the input field is changed by the user, <em>and then</em> a short while later LiveView finds out about it and reacts to it. With no latency, <em>it looks a lot like React</em>. But with increased latency, itâs quite a different paradigm.</p>
<p>In frontend frameworks like React, you need to contend with server-side latency all the time. But <em>when</em> a high-latency action is going to take place is clear (i.e. youâre fetching from a server). In LiveView, the boundary is murkier.</p>
<h3 id="three-components">Three components</h3>
<p>LiveView has three different types of components: LiveViews, LiveComponents, and Components.</p>
<p>LiveViews and LiveComponents are like stateful components in React, whereas Components are like functional components.</p>
<p>Importantly, a LiveView will always be the uppermost parent component. You render LiveComponents and Components as children underneath a LiveView.</p>
<p>In React, it's easy to switch between stateful and functional componentsâjust add or remove <code>useState</code> hooks. The API for both are the same (they both accept props in the same way). And outside state, they have an identical feature set. For example, they can both register and respond to DOM events in the same way.</p>
<p>The ease of switching between component types is important. As an app matures, youâre constantly factoring out components. Youâre figuring out which bits should be reused, what should be generalized, where state should live, etc.</p>
<p>In LiveView, all three components are very different. As a result, refactoring a LiveView into a LiveComponent is surprisingly cumbersome.</p>
<p>In particular:</p>
<ul>
<li>The syntax for rendering and passing props to LiveViews and LiveComponents is different.</li>
<li>The lifecycle of LiveViews and LiveComponents are different.</li>
<li>The <a href="https://hexdocs.pm/phoenix_live_view/Phoenix.LiveComponent.html?ref=blog.sequin.io#module-unifying-liveview-and-livecomponent-communication">communication options</a> between LiveViews and LiveComponents are different. For example, you <code>send</code> to LiveViews but <code>send_update</code> to LiveComponents.</li>
<li>LiveComponents are not processes, and so can't interact with the rest of the system like LiveViews can.</li>
</ul>
<p>That last point is what makes LiveComponents so different and so frustrating. The limitations <em>make sense</em>: A LiveView is a process. That's one of the best parts about a LiveView, they're "just processes" and so they can fit into your Elixir/OTP system like every other process. For example, you can use pub/sub in a LiveView to subscribe to system-wide changes.</p>
<p>A LiveComponent is <em>not</em> its own process, they are modules invoked by a LiveView. The parent LiveView process holds the state for all subcomponents. So, a LiveView has a <code>pid</code>, state, and an inbox; a LiveComponent does not. This means the LiveView also has to handle all message routing for its child LiveComponents.</p>
<p>This is in keeping with Elixir/OTP design principles: processes are the building blocks. To give LiveComponents the same powers of independent state management and action handling, they would each need to be their own process.</p>
<p>Still, for the life of me, I <em>really</em> struggled with LiveComponents. So often, I wanted to send my LiveComponent an event/action but didn't have a good way to do it. You end up using <code>send_update</code>, which is an awkward API. We couldn't decide: do we send <em>actions</em> via <code>send_update</code>, or do we use it to patch state? If we use it to patch state, how do we tell in our <code>update</code> clause whether we're mounting or updating?</p>
<h2 id="the-elusive-%E2%80%9Cliveview-way%E2%80%9D">The elusive âLiveView wayâ</h2>
<p>LiveView often made us feel like we were âmissing something.â The âLiveView wayâ feels elusive.</p>
<p>Perhaps LiveView is in an uncanny valley. It shares a lot in common with contemporary frontend frameworks. So, our âReact brainsâ and intuitions would kick in, driving us to use old patternsâbut those would often lead to a dead end. More alienness would have forced us to recognize the differences and to approach problems differently.</p>
<p>You can do a lot with just LiveView state and actions. But there are limits, and when you hit them you need to switch paradigms.</p>
<p>It has components to help you organize and reuse code. But due to differences between JavaScript and Elixir, LiveView canât really offer the same isomorphic component trees without a ton of abstraction, and so has LiveViews and LiveComponents.</p>
<p><strong>This is what makes LiveSvelte so promising</strong>. As youâll see, it shifts more responsibility to the frontend. It embraces the fact that the frontend will have its own state. And it lets you take advantage of all the maturity of contemporary JavaScript component frameworks.</p>
<h2 id="liveview-svelte">LiveView + Svelte</h2>
<p>LiveSvelte lets you render Svelte components from LiveView. It's an awesome paradigm.</p>
<p>Thereâs a couple different ways to render Svelte from your LiveViews, but the most basic way looks like this:</p>
<pre><code class="language-elixir"># LiveView component
defmodule Web.SyncLive.Form do
  def render(assigns) do
    assigns = 
      assigns
      |&gt; Map.put(:encoded_collections, Enum.map(assigns.collections, &amp;encode_collection/1))
      |&gt; Map.put(:encoded_errors, encode_errors(assigns.changeset))
  
    ~H"""
      &lt;.svelte
        name="MyForm"
        props={
          %{
            collections: @encoded_collections,
            credential_options: @credential_options,
            errors: @encoded_errors,
          }
        }
        socket={@socket}
      /&gt;
    """
  end
end
</code></pre>
<p>This is an Elixir module, the LiveView. Inside the render, we first take our Elixir data structures and encode them for the frontend. We like the pattern of explicitly encoding Elixir structs and such as plain maps before passing to Svelte, like this:</p>
<pre><code class="language-elixir">  defp encode_collection(%Collection{} = collection) do
    %{
      "id" =&gt; collection.id,
      "slug" =&gt; collection.slug,
      "name" =&gt; collection.name
    }
  end
</code></pre>
<p>Weâre able to set props on the Svelte component. Those are passed down as youâd expect to the component:</p>
<pre><code class="language-js">// Svelte component
&lt;script&gt;
  export let resource;
  export let credential_options = [];
  export let errors = {};
  export let live;
&lt;/script&gt;
</code></pre>
<p>One of the props that LiveSvelte sets for us is the <code>live</code> prop. To communicate from the Svelte component back up to the LiveView, we can call <code>live.pushEvent</code>. For example, check how easy it is to send the server changes to the form:</p>
<pre><code class="language-js">&lt;script&gt;
  // ...
  $: {
    live.pushEvent("form_updated", { form }, () =&gt; {});
  }
&lt;/script&gt;
</code></pre>
<p>This is a reactive block in Svelte. It will be executed whenever the variable <code>form</code> is changed. (Kind of like a <code>useEffect</code>, where <code>form</code> is the dependency.)</p>
<p>The LiveView can handle and respond to the <code>pushEvent</code> using typical Elixir message handling semantics:</p>
<pre><code class="language-elixir"># In the LiveView
# ...
  @impl LiveView
  def handle_event("form_updated", %{"form" =&gt; form}, socket) do
    params = decode_params(socket, form)
    {:noreply, merge_changeset(socket, params)}
  end
  
  defp merge_changeset(socket, params) do
    changeset = Collection.create_changeset(socket.assigns.resource, params)

    assign(socket, :changeset, changeset)
  end
</code></pre>
<p>We first decode the params from the frontend, reversing any encoding/mapping we did on the way out. Then, <code>merge_changeset/2</code> updates our changeset. If there are any validation errors in the changeset, those will make their way back to the frontend via the <code>errors</code> prop.</p>
<p>So, you have data flow from Elixir down to the component via props. The LiveView process can update props at any time to cause the Svelte component to re-render. Any other communication can happen via the websocket.</p>
<p>The boundary between the two is very clearâjust as clear as in any SPA.</p>
<p>What's most game-changing, though, is that you have a <em>backend, stateful process</em> that is collaborating with a <em>frontend, stateful process</em>.</p>
<p>And it's <em>so</em> fun and productive.</p>
<p>The three powerhouse properties:</p>
<ol>
<li>The backend controls the props on the frontend component.</li>
<li>The frontend <em>and</em> the backend are stateful.</li>
<li>You have a private, bi-directional communication channel between the two <em>where either side can initiate a message to the other</em>.</li>
</ol>
<p>#1 is made possible thanks to LiveViewâs rendering paradigm: re-renders on the server are automatically pushed and applied to the client. This lets the server update props on the component just like a JS parent component can!</p>
<p>#2 is possible because a LiveView is a process. Processes are how Elixir encapsulates and reduces state.</p>
<p>#3 is made possible by the persistent websocket that LiveView gives you, wired to the frontend.</p>
<p>Consider the differences between this paradigm and a SPA:</p>
<p>First, all browser routing happens via the backend. This is a great simplifier. (In a regular SPA you have to maintain <em>two</em> sets of routes, one for the browser and one for your API.)</p>
<p>Second, the backend is stateful. It knows what route youâre on. Which resource youâre working with. Each action it handles can be far more incremental, as itâs applying a state change to itself vs rebuilding state from scratch.</p>
<p>Third, communication between the frontend and backend is private and coupled, as it should be. Youâre not âpollutingâ your serverâs public routes with a bunch of RPC calls that support a single component. When you see a <code>pushEvent</code> in the client, you know exactly where the handler for that is â in the collaborating Elixir module.</p>
<p>Fourth, functionality is split across just two files. Sure, the backend module will call out to your backend functions (e.g. fetch data from database) and the frontend will import components and styles. But roundtrips between the two arenât routing through a stack of API modules, routers, and controllers.</p>
<p>Fifth, communication between frontend and backend is far less ceremonious. The backend can simply update props to inform frontend changes. And the frontend can <code>pushEvent</code> without needing handlers for expired tokens, timeouts, or outages. Itâs binary: either the websocket is open which means the server is open for business, or itâs not in which case LiveView helpfully shows the user a global âdisconnectedâ banner.</p>
<p>In the simplest terms, the frontend microservice is eliminated.</p>
<p>What you end up with feels like such a great split of responsibilities with very little boilerplate. All your business logic is on the backend â how you load data, <em>which</em> data to load, how to sort and filter the data, your validators, etc. Your frontend code is stupid simple. In Svelte, itâs all (1) <code>if/end</code> blocks to conditionally render stuff (2) animations and (3) a few dead simple <code>pushEvent</code> functions back to the server.</p>
<p>That last part has been blowing my mind. The typical SPA frontend is full of so much logic, usually <code>map</code>, <code>reduce</code>, and <code>filter</code> in order to process server data, prepare data for display, or prepare data for the server. In a LiveSvelte app, all this can just happen server-side. The LiveView can prepare data exactly as the Svelte component needs it. This keeps complexity in your server language, in your server's data structures, and in your server's test suite.</p>
<p>The backend LiveView and the frontend Svelte component aren't so much coupled as they are two halves: the LiveView only renders that Svelte component, and that Svelte component is only ever rendered by that LiveView.</p>
<p>In contrast to a âregularâ LiveView, this paradigm:</p>
<ul>
<li>Embraces state and state transitions in the frontend.</li>
<li>Creates a clear boundary layer between the frontend and backend.</li>
<li>Leverages Svelteâs component paradigm, which like other contemporary JS frameworks is very mature and familiar.</li>
<li>In general, lets great frontend frameworks do what they do best! A pure LiveView approach doesnât let you tap into this huge ecosystem. (For example, Svelte comes with great animation primitives.)</li>
</ul>
<p>By moving more into the frontend, we no longer felt like we were straddling an awkward middleground.</p>
<p>We chose LiveSvelte because React didn't have a similarly complete LiveView library. The joy of working with Svelte has been a very happy bonus. Because LiveView does the heavy lifting with state management, our state management in Svelte is very simple. For basic state and reactivity, Svelte is the lightest and fastest frontend framework I've worked with. We also prefer its templating features to React's, namely getting to use <code>if/else</code> instead of ternary operators and its conditional property setting.</p>
<p>Further, Svelte 5 is around the corner, and we're bullish on its <a href="https://svelte.dev/blog/runes?ref=blog.sequin.io">runes</a>. We think it makes Svelte even easier to pick up and reason about, meaning everyone on the team is empowered to traverse the stack.</p>
<p>Iâm now convinced LiveView shines brightest as a backend-for-frontend. By rendering frontend components, incrementally updating them, maintaining a stateful backend process, and providing a websocket API, it creates a tremendously productive platform for frontend applications.</p>
<p>If youâre using LiveView and resonated with any of the friction I highlighted, you need to give this a try. If youâve never used LiveView, youâll find that this paradigm <em>lowers</em> the learning curve. This is because youâre able to use a lot of the JavaScript framework primitives youâre used to.</p>

    </div>

    <!-- The design of the summary of contents / table of contents is ready, and here. Yet, it still needs to import the headings
    <div class="absolute h-full top-2 -left-72">
      <div class="sticky top-28 p-4 rounded bg-gray-100 w-60 flex flex-col gap-2.5">
        <a class="p-4 bg-black dark:bg-gray-700 dark:hover:bg-gray-600 hover:bg-gray-800 hover:shadow-xl transition-all text-root text-white w-full h-12 rounded inline-flex flex-row items-center cursor-pointer font-bold font-display">
          Introduction  
        </a>
        <a class="p-4  bg-white dark:bg-gray-400 dark:hover:bg-gray-600 hover:bg-gray-200 hover:shadow-xl transition-all text-root text-black w-full h-12 rounded inline-flex flex-row items-center cursor-pointer font-bold font-display">
          Chapter 1  
        </a>
            <a class="p-4 bg-white dark:bg-gray-400 dark:hover:bg-gray-600 hover:bg-gray-200 hover:shadow-xl transition-all text-root text-black w-full h-12 rounded inline-flex flex-row items-center cursor-pointer font-bold font-display">
          Chapter 2  
        </a>
            <a class="p-4 bg-white dark:bg-gray-400 dark:hover:bg-gray-600 hover:bg-gray-200 hover:shadow-xl transition-all text-root text-black w-full h-12 rounded inline-flex flex-row items-center cursor-pointer font-bold font-display">
          Chapter 3  
        </a>
      </div>
    </div>
    -->
    
  </div>
</div>





      </main>

      <footer class="gh-foot">
        <div class="w-full bg-black text-white flex flex-col dark:border-t border-gray-800">
          <div class="mt-16 container px-4 flex flex-col xl:flex-row mx-auto">
            <div class="flex-1 mb-16">
              <img
                class="h-10 inline-block mr-2"
                src="/assets/sequin-logo-brand-white-new.svg"
                alt="Sequin"
              />
            </div>
            <div class="grid grid-cols-2 lg:grid-cols-4 xl:grid-cols-5 gap-20">
              <div class="flex flex-col">
                <h3 class="font-bold text-base text-gray-400">Product</h3>
                <div class="mt-3 grid grid-flow-row gap-y-2">
                  <a class="text-base" href="https://www.sequin.io/pricing">Pricing</a>
                  <a class="text-base" href="https://sequin.io/integrations">Integrations</a>
                  <a class="text-base" href="https://status.sequin.io" target="_blank">Status</a>
                </div>
              </div>
              <div class="flex flex-col">
                <h3 class="font-bold text-base text-gray-400">Company</h3>
                <div class="mt-3 grid grid-flow-row gap-y-2">
                  <a class="text-base" href="https://www.sequin.io/careers">Careers</a>
                  <a class="text-base" href="https://blog.sequin.io/" target="_blank">Blog</a>
                  <a class="text-base" href="mailto:founders@sequin.io" target="_blank">Contact</a>
                </div>
              </div>
              <div class="flex flex-col">
                <h3 class="font-bold text-base text-gray-400">Developers</h3>
                <div class="mt-3 grid grid-flow-row gap-y-2">
                  <a class="text-base" href="https://sequin.io/docs" target="_blank">Docs</a>
                  <a class="text-base" href="https://sequin.io/docs/consumers/postgres" target="_blank">Postgres</a>
                  <a class="text-base" href="https://sequin.io/docs/consumers/kafka" target="_blank">Kafka</a>
                  <a class="text-base" href="https://sequin.io/docs/consumers/nats" target="_blank">NATS</a>
                  <a class="text-base" href="https://sequin.io/docs/consumers/webhooks" target="_blank">Webhooks</a>
                  <a class="text-base" href="https://sequin.io/docs/stream-apis" target="_blank">Streams</a>
                  <a class="text-base" href="https://sequin.io/docs/mutations" target="_blank">Mutations</a>
                </div>
              </div>
              <div class="flex flex-col">
                <h3 class="font-bold text-base text-gray-400">Playbooks</h3>
                <div class="mt-3 grid grid-flow-row gap-y-2">
                  <a class="text-base" href="https://sequin.io/docs/playbooks/materialize" target="_blank">Materialize</a>
                  <a class="text-base" href="https://sequin.io/docs/playbooks/nats" target="_blank">Synadia</a>
                  <a class="text-base" href="https://sequin.io/docs/playbooks/kafka-upstash" target="_blank">Upstash</a>
                  <a class="text-base" href="https://sequin.io/docs/playbooks/postgres-neon" target="_blank">Neon</a>
                  <a class="text-base" href="https://sequin.io/docs/playbooks/postgres-supabase" target="_blank">Supabase</a>
                  <a class="text-base" href="https://sequin.io/docs/how-to/build-a-sync-to-postgres" target="_blank">More...</a>
                </div>
              </div>
              <div class="grid grid-cols-3 gap-x-5">
                <a
                  href="https://www.linkedin.com/company/sequin-io"
                  target="_blank"
                  rel="noreferrer noopener"
                >
                  <img src="/assets/sequin-linkedin.svg" alt="LinkedIn" />
                </a>
                <a
                  href="https://twitter.com/sequin_io"
                  class="mt-1"
                  target="_blank"
                  rel="noreferrer noopener"
                >
                  <img src="/assets/sequin-twitter.svg" alt="Twitter" />
                </a>
                <a
                  href="mailto:founders@sequin.io"
                  target="_blank"
                  rel="noreferrer noopener"
                >
                  <img src="/assets/sequin-email.svg" alt="E-mail" />
                </a>
              </div>
            </div>
          </div>
          <div class="mt-32 container mx-auto px-4">
            <div class="border-gray-800 border-t py-8 flex flex-col xl:flex-row">
              <div class="flex-1 mb-6 xl:mb-0">
                <span class="text-gray-400 text-sm">
                  &copy; Sequin Labs, Inc. 2024
                </span>
              </div>
              <div class="grid grid-flow-col grid-rows-3 md:grid-rows-2 lg:grid-rows-1 gap-8 items-center">
                <a class="text-gray-400 text-sm" href="https://www.sequin.io/terms">Terms of Service</a>
                <a class="text-gray-400 text-sm" href="https://www.sequin.io/privacy">Privacy Policy</a>
                <a class="text-gray-400 text-sm" href="https://www.sequin.io/legal/security">Security</a>
                <a class="text-gray-400 text-sm" href="https://www.sequin.io/legal/dpa">Data Processing</a>
                <a class="text-sm" href="https://status.syncinc.so">
                  <div class="flex flex-row items-center">
                    <div class="h-3 w-3 rounded-full mr-2" style="background: #bbb" id="status-dot"></div>
                    <span id="status-text">Loading...</span>
                  </div>
                </a>
              </div>
            </div>
          </div>
        </div>
      </footer>
    </div>


    <script src="https://blog.sequin.io/assets/built/prism.js?v=8b5ec10fbe"></script>
    <script>
      // Mobile menu toggle
      const btnElem = document.getElementById("hamburger-btn");
      const menuElem = document.getElementById("mobile-menu-popover");

      btnElem.onclick = () => {
        menuElem.classList.toggle("hidden")
      }

      // Header border toggle
      const headerElem = document.getElementById("header-outer");

      window.addEventListener("scroll", () => {
        const scroll = window.scrollY;

        if (scroll) {
          headerElem.classList.add("border-b")
        } else {
          headerElem.classList.remove("border-b")
        }
      })

      // Status check
      const statusDotElem = document.getElementById("status-dot");
      const statusTextElem = document.getElementById("status-text");

      const getDotColor = (status) => {
        switch (status) {
          case "operational":
            return "#73d13d";
          case "partial_outage":
            return "#ffc53d";
          case "degraded_performance":
            return "#ffc53d";
          case "major_outage":
            return "#f5222d";
          default:
            return "#bbb";
        }
      };

      const getStatusText = (status) => {
        switch (status) {
          case "operational":
            return "All systems nominal";
          case "partial_outage":
            return;
          case "degraded_performance":
            return "Systems degraded";
          case "major_outage":
            return "Partial or major outage";
          default:
            return "Error loading status";
        }
      };

      const doStatusCheck = async () => {
        const res = await fetch(
          "https://1btv5z1y42jp.statuspage.io/api/v2/components.json"
        );
        const j = await res.json();
        const component = j.components[0];
        const status = component.status;

        const dotColor = getDotColor(status);
        const statusText = getStatusText(status);

        statusDotElem.style.background = dotColor;
        statusTextElem.innerText = statusText;
      }

      doStatusCheck();
    </script>

    

  </body>
</html>
